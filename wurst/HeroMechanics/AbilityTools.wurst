package AbilityTools

import public AbilityObjEditing
import public Assets
import public RegisterEvents
import public SoundUtils
import public Damage
import public GameSettings
import public GroupUtils
import public UnitStatsSystem
import public TimedSpecialEffects
import public StringUtils

import public ObjectIdGenerator
import ErrorHandling
import BuffObjEditing
import ObjectIds
import DummyRecycler
import CompileTimeData
import HashMap
import Orders
import LinkedList
import ClosureTimers
import OnUnitEnterLeave


public function defineSingleTarget1( string name, string description, string icon, string hotkey, real cooldown, int manaCost, real range, string animation ) returns int
    let abilId = ABIL_ID_GEN.next()
    new AbilityDefinitionChainLightningcreep(abilId)
    ..setupGenerics(name, description, icon, hotkey, cooldown, manaCost)
    ..setDamageperTarget(1, 0)
    ..setAreaofEffect(1, 0)
    ..setCastRange(1, range)
    ..setAnimationNames(animation)
    ..setNumberofTargetsHit(1, 0)
    ..setArtTarget("")
    ..setMissileArt("")
    ..setLightningEffects("")
    return abilId



public function defineSingleTarget2( string name, string description, string icon, string hotkey, real cooldown, int manaCost, real range, string animation ) returns int
    let abilId = ABIL_ID_GEN.next()
    new AbilityDefinitionSeaWitchForkedLightning(abilId)
    ..setupGenerics(name, description, icon, hotkey, cooldown, manaCost)
    ..setCastRange(1, range)
    ..setAnimationNames(animation)
    ..setLevels(1)
    ..setHeroAbility(false)
    ..setDistance(1, 0)
    ..setFinalArea(1, 0)
    ..setDamageperTarget(1, 0)
    ..setAreaofEffect(1, 0)
    ..setNumberofTargetsHit(1, 0)
    ..setArtSpecial("")
    ..setLightningEffects("")
    return abilId

public function defineSingleTarget3( string name, string description, string icon, string hotkey, real cooldown, int manaCost, real range, string animation ) returns int
    let abilId = ABIL_ID_GEN.next()
    new AbilityDefinitionFingerofDeath(abilId)
    ..setupGenerics(name, description, icon, hotkey, cooldown, manaCost)
    ..setCastRange(1, range)
    ..setAnimationNames(animation)
    ..setLevels(1)
    ..setHeroAbility(false)
    ..setArtTarget("")
    ..setDamage(1, 0)
    ..setLightningEffects("")
    ..setGraphicDuration(1, 0.01)
    ..setTargetsAllowed(1, "enemy,ground")
    return abilId


public function defineTargetPoint1( string name, string description, string icon, string hotkey, real cooldown, int manaCost, real range, string animation ) returns int
    let abilId = ABIL_ID_GEN.next()
    new AbilityDefinitionCarrionSwarmcreep(abilId)
    ..setupGenerics(name, description, icon, hotkey, cooldown, manaCost)
    ..setDamage(1, 0)
    ..setDistance(1, 0)
    ..setFinalArea(1, 0)
    ..setAreaofEffect(1, 0)
    ..setCastRange(1, range)
    ..setAnimationNames(animation)
    ..setMissileArt("")
    ..setArtSpecial("")
    return abilId


let instantCast1_Buff = BUFF_ID_GEN.next()
var instantCast1_BuffDefined = false

public function defineInstantCast1( string name, string description, string icon, string hotkey, real cooldown, int manaCost ) returns int
    
    if( not instantCast1_BuffDefined) 
        new BuffDefinition(instantCast1_Buff, 'Bbsk')
        ..setName(1, "")
        ..setTooltipNormal(1, "Hidden buff")
        ..setTooltipNormalExtended(1, "Nothing to see here")
        ..setIcon(Icons.bTNAcorn)
        ..setTargetAttachments(1, 0)
        ..setTargetAttachmentPoint0(1, "")
        ..setTargetAttachmentPoint1(1, "")
        ..setArtTarget(1, "")

    let abilId = ABIL_ID_GEN.next()
    new AbilityDefinitionBeserk(abilId)
    ..setupGenerics(name, description, icon, hotkey, cooldown, manaCost)
    ..setBuffs(1, instantCast1_Buff.toRawCode())
    ..setDamageTakenIncrease(1, 0)
    ..setAttackSpeedIncrease(1, 0)
    ..setMovementSpeedIncrease(1, 0)
    ..setDurationHero(1, 0.01)
    ..setDurationNormal(1, 0.01)
    ..setArtCaster("")

    return abilId

// Immediate cast has a small delay, whereas instant cast is instant
public function defineImmediate1( string name, string description, string icon, string hotkey, real cooldown, int manaCost, string animation ) returns int
    let abilId = ABIL_ID_GEN.next()
    new AbilityDefinitionRoarcreep(abilId)
    ..setupGenerics(name, description, icon, hotkey, cooldown, manaCost)
    ..setBuffs(1, instantCast1_Buff.toRawCode())
    ..setTargetsAllowed(1, "none")
    ..setArtCaster("")
    ..setAreaofEffect(1, 0)
    ..setDamageIncrease(1, 0)
    ..setAnimationNames(animation)

    return abilId


public function AbilityDefinition.setupGenerics(string name, string description, string icon, string hotkey, real cooldown, int manaCost)
    if( not compiletime )
        error("Ability {0} is not being setup during compiletime!".format(name))
    this
    ..setName(name)
    ..setEditorSuffix("")
    ..setIconNormal(icon)
    ..setTooltipNormal( 1, name + "  [" + hotkey.withColor(COLOR_HIGHLIGHT) + "]" )
    ..setTooltipNormalExtended( 1, description + "\n\n" + "Cooldown: ".withColor(COLOR_HIGHLIGHT) + cooldown.toString(0) )
    ..setupHotkey(hotkey)
    ..setCooldown(1, cooldown)
    ..setManaCost(1, manaCost)
    


public function AbilityDefinition.setupHotkey( string hotkey )
    var x = 0
    var y = 2
    
    switch hotkey
        case "Q"
            x = 0
            y = 2
        case "W"
            x = 1
            y = 2
        case "E"
            x = 2
            y = 2
        case "R"
            x = 3
            y = 2
        case "D"
            x = 1
            y = 1
        case "F"
            x = 2
            y = 1
        case "G"
            x = 3
            y = 1

        default
            compileError("Wrong hotkey!")

    this.setButtonPositionNormalX(x)
    this.setButtonPositionNormalY(y)
    this.setHotkeyNormal(hotkey)



//================================================================================================================================================================================================
// Runtime Functions

/** Groups alive units in range who are enemy of p. Uses ENUM_GROUP */
public function enemiesInRange(player p, vec2 origin, real range) returns group
    let g = ENUM_GROUP
    ..clear()
    ..enumUnitsInRange(origin, range)
    
    for u in g
        if( not u.isAlive() or not u.isEnemyOf(p) )
            g.removeUnit(u)

    return g



//================================================================================================================================================================================================
// Buffs

// In pairs: buffId, abilId
let dataObj_CustomBuffs = compiletime(defineDataObj())
let buffAbilMap = new IterableMap<int,int>

/** Define a buff at compiletime, which may be applied using 'unit.applyBuff'. */
public function defineBuff(string name, string description, string icon, string sfx, string attach1, string attach2) returns int
    let attachCount = attach2 != "" ? 2 : 0    

    let buffId = BUFF_ID_GEN.next()
    new BuffDefinition(buffId, 'Binf')
    ..setName(1, name)
    ..setTooltipNormal(1, name)
    ..setTooltipNormalExtended(1, description)
    ..setIcon(icon)
    ..setArtTarget(1, sfx)
    ..setTargetAttachmentPoint0(1, attach1)
    ..setTargetAttachmentPoint1(1, attach2)
    ..setTargetAttachments(1,  attachCount)

    let abilId = ABIL_ID_GEN.next()
    new AbilityDefinitionInnerFireCreep(abilId)
    ..setName(name + "(buff ability)")
    ..setBuffs(1, buffId.toRawCode())
    ..setManaCost(1, 0)
    ..setTargetsAllowed(1, "air,ground,friend,enemy,neutral")
    ..setCastRange(1, 10000)
    ..setDurationHero(1, 0)
    ..setDurationNormal(1, 0)
    ..setCooldown(1, 0)
    ..setEffectSound("")
    ..setDamageIncrease(1, 0)
    ..setDefenseIncrease(1, 0)

    dataObj_CustomBuffs.addData(buffId.toRawCode())
    dataObj_CustomBuffs.addData(abilId.toRawCode())    

    return buffId


init
    let data = dataObj_CustomBuffs.getData()
    while(data.size() > 0)
        buffAbilMap.put(data.dequeue().fromRawCode(), data.dequeue().fromRawCode())


/** Apply buff defined by 'defineBuff' function to this unit */
public function unit.applyBuffSimple(int buffId)
    
    if( not buffAbilMap.has(buffId) )
        error("Buff map doesn't have buff "+buffId.toRawCode())

    let abilId = buffAbilMap.get(buffId)
    let dummy = DummyRecycler.get(this.getPos(), angle(0))
    dummy.addAbility(abilId)
    if( dummy.getAbilityLevel(abilId) == 0 )
        error("Dummy didn't get buff ability (buffId: {0}, abilId: {1}".format(buffId.toRawCode(), abilId.toRawCode()))
    
    dummy.issueTargetOrderById(Orders.innerfire, this)
    DummyRecycler.recycle(dummy)  



let unitBuffMap = new HashMap<unit, IterableMap<int, LinkedList<Buff>>>

public function unit.applyBuff(Buff buffObject, unit source, real duration) 
    buffObject.source = source
    buffObject.target = this
    
    // Create / Get buff map
    if( not unitBuffMap.has(this) )
        unitBuffMap.put(this, new IterableMap<int, LinkedList<Buff>>)
    let buffMap = unitBuffMap.get(this)
    
    // Create / Get buff list
    if( not buffMap.has(buffObject.buffId) )
        buffMap.put(buffObject.buffId, new LinkedList<Buff>)
    let buffList = buffMap.get(buffObject.buffId)

    // Remove existing buff from source
    for unitBuff in buffList
        if( unitBuff.source == source )
            buffList.remove(unitBuff)
            destroy unitBuff

    // Destroying existing buffs if they don't stack
    if( buffList.size() > 0 and not buffObject.stacks )
        for unitBuff in buffList
            buffList.remove(unitBuff)
            destroy unitBuff

    // Apply new buff
    this.applyBuffSimple(buffObject.buffId) // Apply buff (icons, effects etc)
    buffList.add(buffObject)
    buffObject.buffList = buffList
    buffObject.onApply()

    
    // Add duration
    buffObject.durationCb = doAfter(duration) ->
        buffObject.durationCb = null
        destroy buffObject


    

public abstract class Buff
    protected bool stacks
    protected CallbackSingle durationCb = null
    protected LinkedList<Buff> buffList = null // The list of buffs it belongs to

    protected int buffId
    protected unit source = null
    protected unit target = null

    construct(int buffId, bool stacks)
        this.buffId = buffId
        this.stacks = stacks

    ondestroy
        if( durationCb != null )
            destroy durationCb

        // Remove buff From list
        if( buffList != null) 
            buffList.remove(this)

            // Remove actual buff if this was the last buff
            if( buffList.size() == 0 and target != null)
                target.removeAbility(buffId)

        onRemove()

    abstract function onApply()
    abstract function onRemove()


function unit.removeAllBuffs()
    if( unitBuffMap.has(this))
        let buffMap = unitBuffMap.getAndRemove(this)  
        for buffId in buffMap
            let buffList = buffMap.get(buffId)
            for unitBuff in buffList
                unitBuff.onRemove()
                destroy unitBuff
            destroy buffList
        destroy buffMap
    

function unit.removeBuff(int buffId) returns bool
    if( unitBuffMap.has(this) )
        let buffMap = unitBuffMap.get(this)
        if( buffMap.has(buffId) )
            let buffList = buffMap.get(buffId)
            var count = 0
            for unitBuff in buffList
                buffList.remove(unitBuff)
                destroy unitBuff
                count++
            return count > 0            
    return false
    

init
    registerPlayerUnitEvent(EVENT_PLAYER_UNIT_DEATH) ->
        GetDyingUnit().removeAllBuffs()
    
    onLeave() ->
        getEnterLeaveUnit().removeAllBuffs()

            
        
        