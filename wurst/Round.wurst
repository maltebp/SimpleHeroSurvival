package Round

import public UnitSpawner
import public Artifact
import public ItemReward
import public Stats
import public Difficulty

import ErrorHandling
import TimerUtils
import Orb
import Music

import ClosureTimers
import LinkedList
import GladiatorSystem
import GameSettings
import initlater FinishRound
import Players
import TrainingPoints
import Mastery
import UtilCommands

public class Round

//=========================================================================================================================================================

//  Settings 

    private static let HEALTHORB_SPAWNFREQ = 25.
    private static let HEALTHORB_DURATION  = 8.

//=========================================================================================================================================================

 

    private static LinkedList<Round> rounds = new LinkedList<Round>
    
    private static int totalNumberOfRounds = 0
    private static int currentRoundNumber = 0
    private static boolean roundWon = false
    protected static Round currentRound
    private static boolean isBossRound = false
    private static boolean instantSpawn = false



    

    private static boolean aRoundIsRunning = false
    static unit bossUnit = null

    protected let spawners = new LinkedList<UnitSpawner>
    protected int number
    protected int goldReward
    protected int trainingPointsReward
    protected let itemRewards = new LinkedList<ItemReward>
    protected int abilityReward = -1 // Number
    protected real healthOrb_FlatToHealInstant
    protected real healthOrb_PercToHealInstant
    protected real healthOrb_FlatToHealOverTime
    protected real healthOrb_PercToHealOverTime
    protected real healthOrb_SpawnDuration
    protected timer timer_HealthOrbDuration
    protected timer timer_HealthOrbSpawn
    protected string title
    protected string description
    protected string music = Sounds.orcVictory
    protected  int artifactsToRelease = 0 
    protected var level = 0
    protected var playerCount = 0

    protected UnitStatCallback scaleStatsCallback = null


    Round_RemoteFunction codeOnClear = null
    Round_RemoteFunction codeOnPrepare = null
    Round_RemoteFunction codeOnFadeIn = null
    Round_RemoteFunction codeOnStart = null
    Round_RemoteFunction codeOnHeroDeath = null
    Round_RemoteFunction codeOnLastUnitDeath = null


    private static SoundDefinition snd_RoundInfo = new SoundDefinition(Sounds.questLog, false)


// ======================================================================================================================================

// Methods

    //---------------------------------------------------------------------------------------------------------------------------------------
    //  Creation and management functions

    construct() 
         
        totalNumberOfRounds++
        number = totalNumberOfRounds

        if number == 1
            currentRound = this
            currentRoundNumber = 1

        timer_HealthOrbDuration = getTimer()..setData(this castTo int)
        timer_HealthOrbSpawn = getTimer()..setData(this castTo int)
        rounds.push(this)
    
    
    
//---------------------------------------------------------------------------------------------------------------------------------------
// Setters & Adders

    function setReward( int goldReward, int trainingPointsReward)
        this.goldReward = goldReward
        this.trainingPointsReward = trainingPointsReward

    function setCodeOnClear( Round_RemoteFunction whichCode )
        this.codeOnClear = whichCode

    function setCodeOnStart( Round_RemoteFunction whichCode )
        this.codeOnStart = whichCode

    function setCodeOnPrepare( Round_RemoteFunction whichCode )
        this.codeOnPrepare = whichCode

    function addSpawner(UnitSpawner spawner) returns UnitSpawner
        spawners.add(spawner)
        return spawner

        
    function setBossRound()
        isBossRound = true

    /** Manually changes the current round to a certain round. If no round
        of that number exists, it will not do change anything */
    static function setCurrentRound(int roundNumber)
        currentRoundNumber = (roundNumber>totalNumberOfRounds) ? currentRoundNumber : roundNumber
        currentRound = rounds.get(currentRoundNumber-1)

    function setTitle(string title)
        this.title = title
        
    function setDescription(string description)
        this.description = description

    /** Heal over time is heal per tick. It lasts for 6 seconds, so 6 ticks. */
    function setHealthOrbSpawn( real duration, real healthFlatToHealInstant, real healthPercToHealInstant, real healthFlatToHealOverTime, real healthPercToHealOverTime )
        this.healthOrb_SpawnDuration = duration
        this.healthOrb_FlatToHealInstant = healthFlatToHealInstant
        this.healthOrb_PercToHealInstant = healthPercToHealInstant
        this.healthOrb_FlatToHealOverTime = healthFlatToHealOverTime
        this.healthOrb_PercToHealOverTime = healthPercToHealOverTime

    function setMusic(string music)
        this.music = music

        

    /** Adds one or more artifacts as a reward, when winning the round */
    function addArtifactRewards(int numberOfArtifacts)
        this.artifactsToRelease = numberOfArtifacts

    /** Adds one or more artifacts as a reward, when winning the round */
    function addItemRewards(vararg ItemReward items)
        for itemReward in items
            itemRewards.add(itemReward)

    function addAbilityReward(int abilityNumber)
        abilityReward = abilityNumber


    function setCodeOnLastUnitDeath(Round_RemoteFunction whichCode)
        codeOnLastUnitDeath = whichCode
        

    /** Make all rounds instantly spawn all units - only for testing! */
    static function toggleInstantSpawn(boolean toggle)
        instantSpawn = toggle

//---------------------------------------------------------------------------------------------------------------------------------------
// Getters

    function getNumber() returns int
        return number

    static function isARoundRunning() returns boolean
        return aRoundIsRunning

    static function getCurrentRoundNumber() returns int
        return currentRoundNumber

    static function getNumberOfRounds() returns int
        return totalNumberOfRounds

    static function getCurrentRound() returns Round
        return currentRound

    function getTitle() returns string
        return "|cffffcc00Round "+number.toString() + " - "+title+"|r"

    static function getRounds() returns LinkedList<Round>
        return rounds.copy()

    /** Round number the round is scaled with */
    function getLevel() returns int
        return level

    /** Numbers of players the round is scaled with */
    function getPlayerCount() returns int
        return playerCount
    


//---------------------------------------------------------------------------------------------------------------------------------------
//  Running

    
    /** Starts the currentRound */
    static function startRound()

    static function setBossUnit(unit boss)
        bossUnit = boss
        isBossRound = true
            
    function initialize()
        aRoundIsRunning = true
        activateSpawners()
        activateHealthOrbSpawn()
        playMusic(music)

        if codeOnStart != null
            codeOnStart.run(this)
            
    function stopSpawners()
        for spawner in spawners
            spawner.stop()
        
    private function activateSpawners()

        if not spawners.isEmpty()
            for spawner in spawners
                spawner.start()

                if DEBUG and INSTANT_SPAWN
                    spawner.spawnAll()
        
    function clear()
        Orb.destroyAll()
        timer_HealthOrbDuration.pause()
        timer_HealthOrbSpawn.pause()
        if bossUnit != null
            bossUnit.remove()
        for spawner in spawners
            spawner.clear()
        if codeOnClear != null
            codeOnClear.run(this)

    function killSpawnedUnits()
        for spawner in spawners
            spawner.killAll()

    static function clearCurrentRound()
        currentRound.clear()
        
        

    private function activateHealthOrbSpawn()
        timer_HealthOrbDuration.start(healthOrb_SpawnDuration+0.1, function stopHealthOrbSpawn )
        timer_HealthOrbSpawn.startPeriodic(HEALTHORB_SPAWNFREQ, function spawnHealthOrb)
        


    private static function spawnHealthOrb()
        let round = GetExpiredTimer().getData() castTo thistype
        let spawnPos = gg_rct_Arena_Spawn1.randomPoint()

        new HealthOrb(spawnPos)
        ..setHealInstant(round.healthOrb_FlatToHealInstant, round.healthOrb_PercToHealInstant )
        ..setHealOverTime(round.healthOrb_FlatToHealOverTime, round.healthOrb_PercToHealOverTime, HEALTHORB_DURATION )
        

    private static function stopHealthOrbSpawn()
        let round = GetExpiredTimer().getData() castTo thistype
        round.timer_HealthOrbSpawn.pause()

        

    private static function wasLastUnit() returns boolean
        var aliveGladiators = 0
        for gladiator in getAllGladiators()
            if( gladiator.getUnit().isAlive() )
                aliveGladiators++

        if( aliveGladiators > 0 )
            let round = rounds.get(currentRoundNumber-1)
            for spawner in round.spawners
                if not spawner.isFinished() or not spawner.allUnitsAreDead()
                    return false
            return true
        return false
                

    /** Rewards gold, training points and mastery points, and unlock
        new masteries */
    function rewardPoints()
        for p in allPlayers
            p.addGold(goldReward)
            p.addTrainingPoints(TRAINING_POINTS_PER_ROUND)
            p.addMasteryPoints(MASTERY_PER_ROUND)
        unlockMasteryRoundRequirement(number)


    /** Releases all item rewards, and return a list of rewarded items*/
    function rewardItems() returns LinkedList<ItemReward>
        for reward in itemRewards
            reward.release()
        return itemRewards   
        

    static function printNextRound(player p)
        snd_RoundInfo.playForPlayer(p)
        printTimed("\nNext round: \n\n{0}".format(currentRound.toString()),7)
        

    function toString() returns string
        return "Round {0} - {1}\n".format(number.toString(),title).withColor(COLOR_HIGHLIGHT) + description

    
    static function setNextRound()
        if currentRoundNumber < totalNumberOfRounds
            currentRoundNumber++
            currentRound = rounds.get(currentRoundNumber-1)
            aRoundIsRunning = false
        else
            error("No more rounds")


    static function setRoundReady()
        aRoundIsRunning = false

    private static function roundLost()
        roundWon = false
        if bossUnit != null
            bossUnit.setInvulnerable(true)
        currentRound.stopSpawners()
        if currentRound.codeOnHeroDeath != null
            currentRound.codeOnHeroDeath.run(currentRound)
        finishRound(false)

    private static function roundWon()
        roundWon =true
        currentRound.stopSpawners()
        if currentRound.codeOnLastUnitDeath != null
            currentRound.codeOnLastUnitDeath.run(currentRound)
        finishRound(true)


    protected static function anyUnitDies()
        if aRoundIsRunning and not roundWon
            let dying = GetDyingUnit()
            
            if( dying.isGladiator() )
                var allDead = true
                for gladiator in getAllGladiators()
                    if( gladiator.getUnit().isAlive() ) 
                        allDead = false
                if( allDead )
                    roundLost()
            
            else if isBossRound and dying == bossUnit
                roundWon = true
                currentRound.killSpawnedUnits()
                roundWon()           
                    
            else if wasLastUnit()
                doAfter(0.1) ->
                    if wasLastUnit()
                        roundWon()

            
    
    function setStatScalingCallback(UnitStatCallback callback)
        scaleStatsCallback = callback
        

    function prepare()

        if( level == 0)
            level = number

        if( playerCount == 0)
            playerCount = allPlayers.size()

        isBossRound = false
        if codeOnPrepare != null
            codeOnPrepare.run(this)


    function scaleUnitStats(unit u)
        var dmgInc = u.getStatInstance(STAT_DAMAGE).getBaseValue()
        dmgInc *= (level-1) * ROUND_LVL_SCALE_POWER
        dmgInc *= (playerCount-1) * ROUND_PLAYER_SCALE_POWER
        u.adjustStatFlat(STAT_DAMAGE, dmgInc)

        var hpInc = u.getStatInstance(STAT_HEALTH).getBaseValue()
        hpInc *= (level-1) * ROUND_LVL_SCALE_HEALTH
        hpInc *= (playerCount-1) *  ROUND_PLAYER_SCALE_HEALTH
        u.adjustStatFlat(STAT_HEALTH, hpInc)
        

    function getNumberOfItemRewards() returns int
        return itemRewards.size()


               
public interface Round_RemoteFunction
    function run(Round round)
 
                
init
    CreateTrigger()
    ..registerAnyUnitEvent(EVENT_PLAYER_UNIT_DEATH)
    ..addAction(function Round.anyUnitDies)
        

    /*  Single listener on unit stats initialzied for all rounds, to improve
        efficiency. This then call the approriate round's stat adjustment
        callback. */
    afterUnitStatsInitialized() u ->
        if( Round.isARoundRunning() )
            let round = Round.getCurrentRound()
            if( round.scaleStatsCallback == null )
                Log.warn("Stat scaling callback is null for round '{0}'".format(round.getTitle()))
            else
                round.scaleStatsCallback.run(u)
        

//================================================================================================================================================================================================
// CHAT COMMAND

init
    let cmd = defineUtilCommand("round")


    cmd.addSubCommand("level")
    ..addArgument(ArgumentType.INT)
    ..setAction() (p,args,opts) ->
        let round = Round.currentRound
        round.level = args.getInt()
        p.print("\nSet round level to: {0} for round {1}".format(
            round.level.toString().highlight(), Round.currentRound.getTitle().highlight()), 5)
        SND_CLICK.playForPlayer(p)

    cmd.addSubCommand("players")
    ..addArgument(ArgumentType.INT)
    ..setAction() (p,args,opts) ->
        let round = Round.currentRound
        round.playerCount = args.getInt()
        p.print("\nSet player count to: {0} for round {1}".format(
            round.playerCount.toString().highlight(), Round.currentRound.getTitle().highlight()), 5)
        SND_CLICK.playForPlayer(p)

    cmd.addSubCommand("next")
    ..addArgument(ArgumentType.INT)
    ..setAction() (p,args,opts) ->
        let nextRound = args.getInt()
        while( Round.currentRound.number < nextRound )
            Round.currentRound
            ..rewardItems()
            ..rewardPoints()
            if( Round.currentRound.abilityReward > 0)
                for gladiator in getAllGladiators()
                    gladiator.unlockNextAbility()
            Round.setNextRound()

        p.print("\nSet next round to {0}".format(Round.currentRound.getTitle().highlight()), 5)
        SND_CLICK.playForPlayer(p)