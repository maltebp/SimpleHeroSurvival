// ======================================================================================================================================

package Round13

// -------------------------------------------------------------------------------------------------------------------------------------

import Round12
import Game
import Abilities
import AbilityObjEditing
import UnitVisualsUtils
import ObjectIdGenerator
import Icons
import BuffObjEditing
import RegisterEvents
import HashMap
import FadeAndFilters
import Orders
import ErrorHandling
import AutoCastAbility
import Units
import MyLibrary
import Damage
import OnUnitTypeEnter
import Updater
import TimedSpecialEffects
import ObjectIds

// ======================================================================================================================================

// SETTINGS
let WATERBEING_ID   = 'n00Y'
let STORMCALLER_ID  = 'n00V'
let WATERCALLER_ID  = 'n00W'
let MYRMIDON_ID     = 'n00X'


// Tornado
let TORNADO_DAMAGE = 100. // Per second
let TORNADO_RANGE   = 125.
let TORNADO_SPEED   = 50.

// Storm Charge
let STORMCHARGE_DAMAGE = 50.
let STORMCHARGE_RANGE = 125.
let STORMCHARGE_DAMAGEFREQ = 1.

// Wounding Strike
let WOUNDINGSTRIKE_DAMAGE_INITIAL = 100.
let WOUNDINGSTRIKE_DAMAGE_OVERTIME = 20.
let WOUNDINGSTRIKE_COOLDOWN = 15.
let WOUNDINGSTRIKE_DURATION = 5.
let WOUNDINGSTRIKE_ATTACKSPEEDRED = 0.
let WOUNDINGSTRIKE_MOVESPEEDRED = 0.4



// OTHER CONSTANTS
let TORNADOES_ID = compiletime(ABIL_ID_GEN.next())

let WOUNDINGSTRIKE_ABIL_ID = compiletime( ABIL_ID_GEN.next() )
let WOUNDINGSTRIKE_BUFF_ID = compiletime( BUFF_ID_GEN.next() )



// ======================================================================================================================================

init

    Round round
    
    round = new Round()
    ..setReward(30, 3)
    ..setTitle("Naga")
    ..setDescription("...")
    ..setHealthOrbSpawn(125, 75, 0.1, 30, 0.02)

    // // Storm Caller 1
    // round.addSpawner(new UnitSpawner(STORMCALLER_ID, ENEMYPLAYER, vec2(-639,1025), 20))
    // ..setStartDelay(5)
    // ..setFrequencyDeviation(0.1)
    // ..setRandomSpawn(gg_rct_Arena_Spawn1)
    // ..setNearestTargetOnSpawn(GetPlayableMapRect())
    // ..setSoundOnSpawn(Sounds.nagaSirenYesAttack3)
    // ..setSpawnEffect(Abilities.crushingWaveDamage)
    // ..setSpawnCount(2)

    //  // Water Caller 1
    //  round.addSpawner(new UnitSpawner(WATERCALLER_ID, ENEMYPLAYER, vec2(-639,1025), 15))
    //  ..setStartDelay(10)
    //  ..setFrequencyDeviation(0.1)
    //  ..setRandomSpawn(gg_rct_Arena_Spawn1)
    //  ..setNearestTargetOnSpawn(GetPlayableMapRect())
    //  ..setSoundOnSpawn(Sounds.snapDragonYes2)
    //  ..setSpawnEffect(Abilities.crushingWaveDamage)
    //  ..setSpawnCount(8)

    // Myrmidon 1
    round.addSpawner(new UnitSpawner(MYRMIDON_ID, ENEMYPLAYER, vec2(548,1000), 15))
    ..setStartDelay(3)
    ..setFrequencyDeviation(0.01)
    ..setRandomSpawn(gg_rct_Arena_Spawn1)
    ..setNearestTargetOnSpawn(GetPlayableMapRect())
    ..setSoundOnSpawn(Sounds.giantSeaTurtleYes2)
    ..setSpawnEffect(Abilities.crushingWaveDamage)
    ..setSpawnCount(8)

    // Unit Visuals
    UnitVisuals.addUnitType(STORMCALLER_ID)
    ..setPlayerColor(PLAYER_COLOR_AQUA)

    UnitVisuals.addUnitType(WATERCALLER_ID)
    ..setPlayerColor(PLAYER_COLOR_AQUA)

    UnitVisuals.addUnitType(MYRMIDON_ID)
    ..setPlayerColor(PLAYER_COLOR_PEANUT)

    UnitVisuals.addUnitType(WATERBEING_ID)
    ..setPlayerColor(PLAYER_COLOR_AQUA)


    // Ability triggers
    registerSpellEffectEvent(TORNADOES_ID, () -> new TornadoAbility(GetSpellAbilityUnit()))

    // Auto Cast Abilities
    addAutoCastAbilityToUnitType( STORMCALLER_ID, 
        new AutoCastAbilityType(TORNADOES_ID, Orders.tranquility, TargetType.ENEMY_IMMEDIATE, 10000, 0.01, 1) )

     // Auto Cast Abilities
    addAutoCastAbilityToUnitType( MYRMIDON_ID, 
        new AutoCastAbilityType(WOUNDINGSTRIKE_ABIL_ID, Orders.slow, TargetType.ENEMY_UNIT, 1000, 3, WOUNDINGSTRIKE_COOLDOWN) )

    onUnitTypeEnter( STORMCALLER_ID) enteringUnit ->
        print("Unit entered the map!")
        StormChargeBuff.applyToUnit(enteringUnit, STORMCHARGE_DAMAGE, STORMCHARGE_RANGE)

// ======================================================================================================================================
// TORNADO


// Ability Class
class TornadoAbility

    private static let UPDATE_FREQ = 0.1
    private static let ANIMATION_FREQ = 1.167
    private static let instances = new IterableMap<unit, thistype>
    
    private unit caster
    private timer timer_Update
    private timer timer_Animation

    construct( unit caster )

        this.caster = caster

        if instances.has(caster)
            destroy this
            error("Caster already exists in instances")

        else
            instances.put(caster, this)

            timer_Update = getTimer()
            ..setData( this castTo int )
            ..startPeriodic(UPDATE_FREQ, () -> GetExpiredTimer().getData() castTo thistype.update() )

            timer_Animation = getTimer()
            ..setData( this castTo int )
            ..startPeriodic(ANIMATION_FREQ, () -> GetExpiredTimer().getData() castTo thistype.doAnimation() )

            doAnimation()

            let spawnPos = caster.getPos().moveTowards(hero.getPos(), 150)
            new Tornado(caster, hero, spawnPos, TORNADO_SPEED, TORNADO_DAMAGE, TORNADO_RANGE)
            ..destroyOnSourceDeath(true)


    ondestroy
        if caster == null
            instances.removeValue(this, true)
        else
            instances.remove(caster)

        timer_Update.release()
        timer_Animation.release()

    
    private function doAnimation()
        caster.setAnimation("spell")


    private function update()
        if caster == null or not caster.isAliveTrick() or caster.getCurrentOrder() != Orders.tranquility 
            destroy this


// Tornado
class Tornado

    private static let SOUND = new SoundDefinition(Sounds.cycloneLoop1, true, true)
    private static let MOVEFREQ = 0.01
    private static let DAMAGEFREQ = 1.
    private static let instances = new LinkedList<thistype>
    
    private real movePerUpdate
    private real speed
    private real damage
    private unit target
    private real range
    private unit source
    private unit soundUnit

    private sound snd

    private effect tornado
    private vec2 pos

    private var destroyOnSourceDeath = false

    private timer timer_Update
    private timer timer_Damage

    construct(unit source, unit target, vec2 spawnPos, real speed, real damage, real range)

        this.target = target
        this.pos = spawnPos
        this.speed = speed
        this.damage = damage
        this.range = range
        this.source = source

        movePerUpdate = speed * MOVEFREQ

        
        soundUnit = createUnit(Player(PLAYER_NEUTRAL_PASSIVE), 'h002', pos, angle(0))
        snd = SOUND.play(500000).snd
        snd.setVolume(90)
        AttachSoundToUnit(snd, soundUnit)
        

        tornado = addEffect(Abilities.tornadoElementalSmall, pos)
        ..setScale(0.75)
        ..setColor(175, 255, 230)
        
        timer_Update = getTimer()
        ..setData(this castTo int)
        ..start(1.1, () -> GetExpiredTimer().getData() castTo thistype.enableMove())

        timer_Damage = getTimer()
        ..setData(this castTo int)

        instances.add(this)
        

    ondestroy
        tornado
        ..setTimeScale(2)
        ..destr()
        
        soundUnit.remove()
        snd.stop(false,true)

        timer_Update.release()
        timer_Damage.release()

        instances.remove(this)
        

    private function enableMove()
        timer_Update.startPeriodic(MOVEFREQ, () -> GetExpiredTimer().getData() castTo thistype.move() )
        timer_Damage.startPeriodic(DAMAGEFREQ, () -> GetExpiredTimer().getData() castTo thistype.damage() )
    

    private function damage()
        let targets = ENUM_GROUP
        ..clear()
        ..enumUnitsInRange(pos, range)

        for target from targets
            
            if target.isAliveTrick() and target.isEnemyOf(source)
                source.damageTargetSpell(target, damage)


    private function move()

        if target == null or not target.isAliveTrick()
            destroy this

        else if destroyOnSourceDeath and (source == null or not source.isAliveTrick())
            destroy this

        else
            pos = pos.moveTowards(target.getPos(), movePerUpdate)
            tornado.setPos(pos)
            soundUnit.setPos(pos)
            

        
    function destroyOnSourceDeath(boolean toggle)
        destroyOnSourceDeath = toggle


// Generating ability
@compiletime
function generateTornadoAbility()

    new BuffDefinition(BUFF_ID_GEN.next(), 'xEtq')
    ..setAreaEffect(1, "")

    new AbilityDefinitionKeeperoftheGroveTranquility(TORNADOES_ID)
    ..setName("Tornadoes")
    ..setHeroAbility(false)
    ..setManaCost(1, 0)
    ..setAreaofEffect(1, 0)
    ..setAnimationNames("stand")
    ..setArtCaster("")
    ..setArtTarget("")
    ..setAreaEffect("")
    ..setTargetsAllowed(1, "none")
    ..setDurationHero(1, 1000)
    ..setDurationNormal(1, 1000)
    ..setCooldown(1, 0)
    ..setTooltipNormal(1, "Tornadoes")
    ..setTooltipNormalExtended(1, "")
    ..setIconNormal(Icons.bTNTornado)
    ..setEffects(1, "")



// ====================================================================================================================================

let STORMCHARGE_BUFF = compiletime(createDummyBuffObject("Storm Charged", "This unit is charge with the power of the storm. All enemies around it takes damage periodically.",
     Icons.bTNOrbOfLightning, Abilities.purgeBuffTarget, "origin"))

class StormChargeBuff extends Updater

    private static let instances = new IterableMap<unit,thistype>

    private unit chargedUnit
    private real damage
    private real range

    construct( unit chargedUnit, real damage, real range )
        this.chargedUnit = chargedUnit
        this.damage = damage
        this.range = range
    
        chargedUnit.addAbility( STORMCHARGE_BUFF.abilId )

        updateFreq = STORMCHARGE_DAMAGEFREQ

        startUpdate()

        instances.put(chargedUnit, this)
    

    ondestroy

        if chargedUnit != null
            instances.remove(chargedUnit)

        else
            instances.removeValue(this, true)


    override function update()
        
        if chargedUnit == null or not chargedUnit.isAliveTrick()
            destroy this

        else
            let targets = ENUM_GROUP..enumUnitsInRange(chargedUnit.getPos(), range)

            for target in targets
                if target != chargedUnit and target.isEnemyOf(chargedUnit) and target.isAliveTrick()
                    chargedUnit.damageTargetSpell(target, damage)
                    target.addEffect( Abilities.lightningShieldBuff, "origin")
                    ..setDuration(2)


    
    static function applyToUnit( unit whichUnit, real damage, real range )
        
        if instances.has(whichUnit)
            destroy instances.get(whichUnit)

        new StormChargeBuff( whichUnit, damage, range )



// ====================================================================================================================================
// WOUNDING STRIKE




@compiletime
function generateWoundingStrike()

    new BuffDefinition( WOUNDINGSTRIKE_BUFF_ID, 'Bslo' )
    ..setIcon( Icons.bTNImpale )
    ..setName(1, "Wounding Strike")
    ..setTooltipNormal(1, "Wounding Strike")
    ..setTooltipNormalExtended(1, "Slowed and takes damage over time!")
    ..setArtTarget(1, "")

    new AbilityDefinitionSlowCreep(WOUNDINGSTRIKE_ABIL_ID)
    ..setArtCaster(Abilities.impaleHitTarget)
    ..setCasterAttachmentPoint("chest")
    ..setAnimationNames("attack")
    ..setName("Wounding Strike")
    ..setDurationHero(1, WOUNDINGSTRIKE_DURATION)
    ..setDurationNormal(1, WOUNDINGSTRIKE_DURATION)
    ..setAttackSpeedFactor(1, WOUNDINGSTRIKE_ATTACKSPEEDRED)
    ..setMovementSpeedFactor(1, WOUNDINGSTRIKE_MOVESPEEDRED)
    ..setManaCost(1, 0)
    ..setCastRange(1, 150)
    ..setBuffs(1, WOUNDINGSTRIKE_BUFF_ID.toRawCode() )









// ======================================================================================================================================





// ======================================================================================================================================


    

