package ComboUnit

import ComboPoint
import LinkedList
import ComboMove
import ClosureTimers
import ErrorHandling

let MAX_POINTS = 3


public class ComboUnitDefinition
    static let definitions = new LinkedList<thistype>

    protected int unitTypeId
    protected int comboList
    protected let unlockedMoves = new LinkedList<ComboMove>
    protected let lockedMoves = new LinkedList<ComboMove>

    construct( int unitTypeId )
        this.unitTypeId = unitTypeId 
        this.comboList = comboList
        definitions.add(this)

    static function getDefinition( unit whichUnit ) returns thistype
        let unitTypeId = whichUnit.getTypeId()
        for definition in definitions
            if definition.unitTypeId == unitTypeId
                return definition
        return null    

    function addComboMoves( vararg ComboMove comboMoves )
        for comboMove in comboMoves
            this.lockedMoves.add(comboMove)

    function unlockMove() returns ComboMove
        if lockedMoves.size() > 0
            let move = lockedMoves.removeAt(0)
            unlockedMoves.add(move)
            return move
        else    
            error("No more moves to unlock")
            return null
        


/**
    Keeps track of a unit's current combo. It doesn't track it all the time,
    only when it actually has a combo.
*/
public class ComboUnit
    private static let instances = new LinkedList<thistype>
    private CallbackPeriodic updateCb = null

    ComboUnitDefinition definition 

    unit comboUnit
    LinkedList<ComboPoint> currentCombo = new LinkedList<ComboPoint>
    ComboMove currentMove = null

    private let WIDTH_PER_POINT = 50.
    private let WIDTH_TOTAL = WIDTH_PER_POINT * (MAX_POINTS-1)
    private let POINT_Z_OFFSET = 270.


    construct( unit comboUnit )
        this.comboUnit = comboUnit
        definition = ComboUnitDefinition.getDefinition(comboUnit)

        instances.add(this)

        if instances.size() == 1
            updateCb = doPeriodically(0.01) cb ->
                for instance in instances
                    instance.update() 
        

    ondestroy
        clearMoves()
        removeAllComboPoints()

        instances.remove(this)
        if instances.size() == 0
            destroy updateCb
        
    
    
    function update()
       
        if comboUnit == null or not comboUnit.isAlive() or currentCombo.size() == 0
            destroy this

        else
            var pointPos = comboUnit.getPos().withTerrainZ() + vec3( -WIDTH_TOTAL/2, 0, POINT_Z_OFFSET)

            for comboPoint in currentCombo
                comboPoint.updatePos( pointPos )
                pointPos += vec2(WIDTH_PER_POINT, 0)        
        

    function updateMoves()
        
        for comboMove in definition.unlockedMoves

            if comboMove.getSize() == currentCombo.size()
                boolean comboMatch = true

                for i = 0 to comboMove.getSize()-1 

                    if currentCombo.get(i).getType() != comboMove.getComboPointType(i)
                        comboMatch = false
                        
                if comboMatch
                    clearMoves()
                    comboUnit.addAbility( comboMove.getAbilityId() )

            else if comboUnit.hasAbility(comboMove.getAbilityId())
                comboUnit.removeAbility(comboMove.getAbilityId())
        

    function clearMoves()
        for comboMove in definition.unlockedMoves
            if comboUnit.hasAbility(comboMove.getAbilityId())
                comboUnit.removeAbility(comboMove.getAbilityId())


    function addComboPoint( ComboPointType pointType ) returns boolean 
        if currentCombo.size() < MAX_POINTS
            currentCombo.add( new ComboPoint( pointType ) )
            updateMoves()
            return true
        return false

    function removeAllComboPoints()
        for comboPoint in currentCombo
            destroy comboPoint
        currentCombo.clear() 
        clearMoves()

    function removeLastComboPoint()
        if currentCombo.size() > 0
            destroy currentCombo.pop()
            updateMoves()


    function removeFirstComboPoint()
        if currentCombo.size() > 0
            destroy currentCombo.removeAt(0)
            updateMoves()

        
    static function getInstance( unit whichUnit ) returns thistype  
        for instance in instances
            if instance.comboUnit == whichUnit
                return instance
        return new ComboUnit(whichUnit)


    static function hasInstance( unit whichUnit ) returns boolean
        for instance in instances
            if instance.comboUnit == whichUnit
                return true
        return false


// =============================================================================
// Unit enters Map