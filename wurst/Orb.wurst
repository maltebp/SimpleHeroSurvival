package Orb

import TimerUtils
import SoundUtils
import LinkedList
import TimedSpecialEffects

class Orb

    protected static constant LinkedList<Orb> orbs = new LinkedList<Orb>
    protected static constant real ACTIVATION_RANGE = 125
    protected static constant real UPDATE_FREQ = 0.2

    private static timer updateTimer    

    protected vec2 pos
    protected LinkedList<unit> activationUnits

    protected effect orb
    protected effect additionalSfx1

    construct( playercolor orbColor, vec2 pos)
        this.pos = pos
        orb = addEffect("units\\nightelf\\Wisp\\Wisp.mdl", pos)
        ..setColorByPlayer(orbColor.getPlayer())
        ..setTimeScale(0.5)
        orbs.add(this)
        startUpdate()

    ondestroy
        print("destroying orb")
        orbs.remove(this)
        orb.destr()
        if additionalSfx1 != null
            additionalSfx1.destr()

        if orbs.size() == 0
            updateTimer
            ..pause()
            ..release()

    /** For testing purposes */
    protected static function printOrbs()
        if orbs.size() > 0
            for orb in orbs
                print(orb castTo int)
        
        
    private static function startUpdate()
        if orbs.size() == 1
            updateTimer = getTimer()
            ..startPeriodic( UPDATE_FREQ, function update )      

    private static function update()
        
        for orb in orbs
            group unitsInRange = ENUM_GROUP
            unitsInRange.enumUnitsInRange(orb.pos, ACTIVATION_RANGE)
            
            // Checking if any units are in range
            if unitsInRange.size() > 0

                // Sorting dead units
                for unitInRange in unitsInRange
                    if not unitInRange.isAliveTrick()
                        unitsInRange.removeUnit(unitInRange)

                // Sorting set activationUnits
                if orb.activationUnits != null
                    for unitInRange in unitsInRange
                        if not orb.activationUnits.contains(unitInRange)
                            unitsInRange.removeUnit(unitInRange)
                
                // Finding the nearest Unit
                if unitsInRange.size() > 1
                    unit nearestUnit = null
                    real distanceToNearestUnit = 99999
                    for unitInRange from unitsInRange
                        real distanceToUnitInRange = unitInRange.getPos().distanceTo(orb.pos)
                        if distanceToUnitInRange < distanceToNearestUnit
                            nearestUnit = unitInRange
                            distanceToNearestUnit = distanceToUnitInRange

                    orb.consume(nearestUnit)
                    
                else if unitsInRange.size() > 0
                    orb.consume(unitsInRange.next())
                    
                unitsInRange.clear()
            

    
    function consume(unit whichUnit)
        print("consuming orb")


public class HealthOrb extends Orb

     

    construct(vec2 pos)
        super(PLAYER_COLOR_GREEN, pos)
        print("Creating health orb!")
        //orbs.add(this)
        Orb.printOrbs()

    ondestroy
        print("destroying health orb")
        Orb.printOrbs()
        
    function addAdditionalEffect( string sfxPath ) returns effect
        additionalSfx1 = addEffect(sfxPath, pos)
        return additionalSfx1

    function setHealOverTime()

    function setHealInstant()
    
    override function consume(unit whichUnit)
        whichUnit.addEffect("Abilities\\Spells\\NightElf\\ManaBurn\\ManaBurnTarget.mdl", "chest")
        ..setDuration(3)
        print("Consuming health orb")
        destroy this
        
init
    new HealthOrb(vec2(100,-90))
    new HealthOrb(vec2(600,-90))
    new HealthOrb(vec2(360,-90))